<!doctype html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>Canvas Drag and Drop Test</title>
</head>

<body>
    <section>
        <div>
            <canvas id="canvas" width="300" height="300">
                This text is displayed if your browser does not support HTML5 Canvas.
            </canvas>
        </div>

        <script type="text/javascript">
            var delay = 50;
            var context;
            var canvas;
            var shapes = [];
            var id = 1;
            var WIDTH = 300;
            var HEIGHT = 300;
            var clickedShape;
            var redrawCanvas = false;

            function line(startPoint, endPoint) {
                this.start = startPoint;
                this.end = endPoint;
            }

            function point(x, y) {
                this.x = x;
                this.y = y;
            }

            function getDrawPoints(x, y, points) {
                let drawPoints = [];
                points.forEach(function (point2) {
                    drawPoints.push(new point(point2.x - x, point2.y - y));
                })
                return drawPoints;
            }

            function getPoints(x, y, points) {
                let points2 = [];
                points.forEach(function (point2) {
                    points2.push(new point(point2.x + x, point2.y + y));
                })
                return points2;
            }

            function shape(type, points) {
                switch (type) {
                    case 1:
                        this.x = points[0].x;
                        this.y = points[0].y;
                        break;
                    case 2:
                        this.x = points[0].x;
                        this.y = points[0].y;
                        this.drawPoints = getDrawPoints(this.x, this.y, points);
                        this.points = points;
                        break;
                    default:
                        this.x = points[0].x;
                        this.y = points[0].y;
                }

                this.deltaX = null;
                this.deltaY = null;
                this.type = type;
                this.crossed = false;
                this.id = id;
                id++;
            }

            function rect(shape, w, h) {
                context.beginPath();
                context.rect(shape.x, shape.y, w, h);
                context.closePath();
                context.stroke();
                if (shape.crossed) {
                    context.fill();
                }
            }

            function polygon(shape) {
                context.beginPath();
                context.moveTo(shape.drawPoints[0].x + shape.x, shape.drawPoints[0].y + shape.y);
                shape.drawPoints.forEach(function (point) {
                    context.lineTo(point.x + shape.x, point.y + shape.y)
                });
                context.lineTo(shape.drawPoints[0].x + shape.x, shape.drawPoints[0].y + shape.y);
                context.stroke();
                if (shape.crossed) {
                    context.fill();
                }
            }

            function clear() {
                context.clearRect(0, 0, WIDTH, HEIGHT);
            }

            function needsRedraw() {
                redrawCanvas = true;
            }

            function draw() {
                if (redrawCanvas) {
                    clear();
                    context.fillStyle = "#FFFF00";
                    rect(new shape(1, [new point(0, 0)]), WIDTH, HEIGHT);

                    shapes.forEach(function (shape) {
                        if (shape.type == 1) {
                            rect(shape, 30, 30);
                        }
                        else {
                            polygon(shape);
                        }
                    });

                    redrawCanvas = false;
                }
            }

            function inPoly(x, y, points) {
                npol = points.length;
                j = npol - 1;
                var c = false;
                for (i = 0; i < npol; i++) {
                    if ((((points[i].y <= y) && (y < points[j].y)) || ((points[j].y <= y) && (y < points[i].y))) &&
                        (x > (points[j].x - points[i].x) * (y - points[i].y) / (points[j].y - points[i].y) + points[i].x)) {
                        c = !c
                    }
                    j = i;
                }
                return c;
            }

            function isClicked(e, shape) {
                if (shape.type == 1) {
                    return shape.x < e.pageX - canvas.offsetLeft && e.pageX - canvas.offsetLeft < shape.x + 30
                        && shape.y < e.pageY - canvas.offsetTop && e.pageY - canvas.offsetTop < shape.y + 30;
                } else {
                    return inPoly(e.pageX - canvas.offsetLeft, e.pageY - canvas.offsetTop, shape.points)
                }
            }

            function move(e) {
                if (clickedShape) {
                    clickedShape.x = e.pageX - canvas.offsetLeft - clickedShape.deltaX;
                    clickedShape.y = e.pageY - canvas.offsetTop - clickedShape.deltaY;
                    needsRedraw();
                }
            }

            function down(e) {
                shapes.forEach(function (shape) {
                    if (isClicked(e, shape)) {
                        clickedShape = shape;
                        return;
                    }
                });

                if (clickedShape) {
                    clickedShape.deltaX = (e.pageX - canvas.offsetLeft) - clickedShape.x;
                    clickedShape.deltaY = (e.pageY - canvas.offsetTop) - clickedShape.y;

                    needsRedraw();
                    canvas.onmousemove = throttle(move, delay);
                }
            }

            function makeLines(shape) {
                let lines = [];
                if (shape.type == 2) {
                    for (i = 0; i < shape.points.length; i++) {
                        lines.push(new line(shape.points[i], shape.points[(i + 1) % shape.points.length]))
                    }
                } else {
                    lines.push(new line(new point(shape.x, shape.y), new point(shape.x + 30, shape.y)));
                    lines.push(new line(new point(shape.x + 30, shape.y), new point(shape.x + 30, shape.y + 30)));
                    lines.push(new line(new point(shape.x + 30, shape.y + 30), new point(shape.x, shape.y + 30)));
                    lines.push(new line(new point(shape.x, shape.y + 30), new point(shape.x, shape.y)));

                }

                return lines;
            }

            function vectorMulti(ax, ay, bx, by) {
                return ax * by - bx * ay;
            }

            function realLess(a, b) {
                return b - a > 0.01;
            }

            function isLineCrossed(lineA, lineB) {
                let v1 = vectorMulti(
                    lineB.end.x - lineB.start.x, lineB.end.y - lineB.start.y, lineA.start.x - lineB.start.x, lineA.start.y - lineB.start.y);
                let v2 = vectorMulti(
                    lineB.end.x - lineB.start.x, lineB.end.y - lineB.start.y, lineA.end.x - lineB.start.x, lineA.end.y - lineB.start.y);
                let v3 = vectorMulti(
                    lineA.end.x - lineA.start.x, lineA.end.y - lineA.start.y, lineB.start.x - lineA.start.x, lineB.start.y - lineA.start.y);
                let v4 = vectorMulti(
                    lineA.end.x - lineA.start.x, lineA.end.y - lineA.start.y, lineB.end.x - lineA.start.x, lineB.end.y - lineA.start.y);

                return realLess(v1 * v2, 0) && realLess(v3 * v4, 0)
            }

            function isCrossed(currentShape) {
                let flag = false;
                let linesCurrentShape = makeLines(currentShape);

                shapes.forEach(function (shape) {
                    if (shape.id != currentShape.id) {
                        let linesShape = makeLines(shape);
                        linesCurrentShape.forEach(function (line) {
                            linesShape.forEach(function (lineTest) {
                                if (isLineCrossed(line, lineTest)) {
                                    flag = true;
                                    return;
                                }
                            });
                        });
                    }
                });

                return flag;
            }

            function checkForIntersection() {
                shapes.forEach(function (shape) {
                    shape.crossed = isCrossed(shape);
                });
            }

            function up() {
                canvas.onmousemove = null;

                if (clickedShape && clickedShape.type == 2) {
                    clickedShape.points = getPoints(clickedShape.x, clickedShape.y, clickedShape.drawPoints);
                }

                clickedShape = null;
                checkForIntersection();
                needsRedraw();
            }

            function init() {
                canvas = document.getElementById("canvas");
                context = canvas.getContext("2d");
                shapes.push(new shape(1, [new point(70, 70)]));
                shapes.push(new shape(1, [new point(10, 10)]));
                shapes.push(new shape(1, [new point(10, 10)]));
                shapes.push(new shape(2, [new point(10, 10), new point(40, 30), new point(50, 20), new point(70, 80)]));
                shapes.push(new shape(2, [new point(10, 10), new point(10, 40), new point(70, 70), new point(80, 20)]));
                needsRedraw();
                return setInterval(draw, delay);
            }


            init();
            canvas.onmousedown = down;
            canvas.onmouseup = up;

            function throttle(func, ms) {

                var isThrottled = false,
                    savedArgs,
                    savedThis;

                function wrapper() {

                    if (isThrottled) {
                        savedArgs = arguments;
                        savedThis = this;
                        return;
                    }

                    func.apply(this, arguments);

                    isThrottled = true;

                    setTimeout(function () {
                        isThrottled = false;
                        if (savedArgs) {
                            wrapper.apply(savedThis, savedArgs);
                            savedArgs = savedThis = null;
                        }
                    }, ms);
                }

                return wrapper;
            }

        </script>
    </section>
</body>

</html>